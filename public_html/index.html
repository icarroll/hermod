<html>
<head>
  <!-- <script src="vue.min.js"></script> -->
  <script src="vue.js"></script>
  <script src="jdenticon.min.js"></script>
  <script>
    window.jdenticon_config = {
      lightness: {
        color: [0.33, 0.67],
        grayscale: [0.17, 0.67],
      },
      saturation: {
        color: 1.0,
        grayscale: 0.0,
      },
      backColor: "#ffffff"
    };
  </script>
  <script src="sodium.js"></script>
  <script src="zxcvbn.js"></script>
  <script src="moment.js"></script>
  <script src="moment-timezone-with-data.js"></script>

<style>
[data-tooltip] {
  position: relative;
}

[data-tooltip]:after {
  visibility: hidden;
  z-index: 1;
  position: absolute;
  content: attr(data-tooltip);
  width: auto;
  max-width: min-content;
  height: auto;
  background-color: white;
  border: 1px solid black;
}

[data-tooltip]:hover:after {
  visibility: visible;
}

.visible {
}

.invisible {
  display: none;
}

.login {
  height: 100%;
  display: grid;
  grid-template-columns: 1fr 2fr 1fr;
  grid-template-rows: 1fr 2fr 2fr 1fr;
}

.unamepword {
  grid-column: 2;
  grid-row: 2;
}

#calculate {
  grid-column: 2;
  grid-row: 3;
}

#chat {
  height: 100%;
  display: grid;
  grid-template-columns: 80% 20%;
  grid-template-rows: 85% 15%;
}

.homebutton {
  position: absolute;
  z-index: 2;
  top: 0;
  right: calc(20% + 32px);
  width: 32px;
  height: 32px;
  font-weight: bold;
}

.newbutton {
  position: absolute;
  z-index: 2;
  top: 0;
  right: 20%;
  width: 32px;
  height: 32px;
  font-weight: bold;
}

.newdiv {
  position: absolute;
  z-index: 2;
  top: 32px;
  right: 20%;
}

svg {
  border: 1px solid black;
}

#logs {
  grid-column: 1;
  grid-row: 1;

  display: flex;
  flex-direction: row;
}

.channel {
  flex-basis: 0;
  flex-grow: 1;
  border-right: 1px solid black;

  display: flex;
  flex-direction: column;
}

.channelname {
  flex-basis: auto;
  flex-grow: 0;
  border-bottom: 1px solid black;
}

.activechannel .channelname {
  border-bottom: 5px solid blue;
}

.leavebutton {
  padding: 0;
}

.chatlog {
  flex-basis: 0;
  flex-grow: 1;
  overflow-y: scroll;
}

.chatlog div::after {
  /* clearfix hack */
  content: "";
  clear: both;
  display: table;
}

.msg {
  background: #f7f7f7;
  margin-right: 10px;
}

.msg svg {
  float: left;
}

.msgitem {
  margin-left: 42px;
  margin-block-end: 0;
}

.msgtext {
  word-break: break-word;
}

.timestamp {
  font-style: italic;
  font-size: small;
  color: grey;
  float: right;
  border-left: 1px solid grey;
  border-bottom: 1px solid grey;
  padding-left: 3px;
}

#who {
  grid-column: 2;
  grid-row: 1;

  overflow-y: scroll;

  padding-left: 10px;
}

div:empty + #who {
  border-left: 1px solid black;
}

#who ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

textarea {
  font-family: serif;
  resize: none;
}

#input {
  padding-top: 10px;
  grid-column: 1 / span 2;
  grid-row: 2;

  border-top: 1px solid black;

  display: grid;
  grid-template-columns: auto auto 1fr;
}

#input strong {
  padding-left: 10px;
  padding-right: 10px;
}

.sockmsg {
  position: absolute;
  bottom: 0;
  left: 0;
}
</style>

<script>
function calculate() {
  app.idkey_state = "show";

  app.self_user.nickname = app.self_user.id_salt;

  seed = sodium.crypto_pwhash(32, app.self_user.password, sodium.crypto_generichash(16, app.self_user.id_salt), 12, 10000000, sodium.crypto_pwhash_ALG_ARGON2ID13)
  keypair = sodium.crypto_sign_seed_keypair(seed);
  app.self_user.privkey = keypair.privateKey;
  app.self_user.idkey = keypair.publicKey;

  update_icons();
  Vue.nextTick(function () {
    app.$refs.nickname.focus();
  });
}

function connect() {
  // app.websocket = new WebSocket("ws://" + window.location.host + ":8192" + window.location.pathname.substring(0, window.location.pathname.lastIndexOf("/")) + "/chatsock");
  // app.websocket = new WebSocket("ws://" + window.location.host + ":8192" + "/chatsock");
  app.sockmsg = "Connecting...";

  app.websocket = new WebSocket("ws://ada.cs.pdx.edu:8192/")

  app.websocket.onmessage = function (e) {
    var receive = JSON.parse(e.data);

    if (! ("idkey" in receive)) {console.log("no idkey"); return;}
    var decidkey = decode_idkey(receive.idkey);

    if (! ("payload" in receive)) {console.log("no payload"); return;}
    //TODO verify signature
    var payload = JSON.parse(receive.payload);

    if (! ("timestamp" in payload)) {console.log("no timestamp"); return;}
    //TODO verify timestamp

    if (! (decidkey in app.users)) {
      //TODO recognize own idkey
      app.users[decidkey] = {nickname: ""};
      app.$forceUpdate();
      update_icons();
    }

    app.users[decidkey].lastseen = moment();
    app.users[decidkey].lastcalled = moment();

    if ("who" in payload) {
      //TODO don't respond to own who
      Vue.nextTick(function () {
        app.send_listen();
      });
    }

    if ("call" in payload) {
      var youridkey = decode_idkey(payload.call);
      if (youridkey === app.self_user.idkey) {
        Vue.nextTick(function () {
          app.send_listen();
        });
      }
      else if (youridkey in app.users) {
        app.users[youridkey].lastcalled = moment();
      }
    }

    if ("listen" in payload) {
      //TODO update channel member lists
    }

    if ("nickname" in payload) {
      app.users[decidkey].nickname = payload.nickname;
    }

    if ("say" in payload) {
      for (var channel in payload.say) {
        item = {idkey: decidkey,
                nickname: app.users[decidkey].nickname,
                message: payload.say[channel],
                timestamp: payload.timestamp};
        post_message(channel, item)
      }
    }
  }

  app.websocket.onopen = function (e) {
    var encidkey = btoa(String.fromCharCode(...app.self_user.idkey));
    var obj = {idkey:encidkey, nickname:app.self_user.nickname, join:[""]};
    // app.websocket.send(JSON.stringify(obj));

    app.sockmsg = "Connected";
    app.state="chat";

    window.onbeforeunload = function() {return true;};
    app.join("");
    app.send_who();
  }

  app.websocket.onclose = function (e) {
    app.sockmsg = "Not Connected";
  }
}

function encode_idkey(idkey) {
  var encidkey = btoa(String.fromCharCode(...idkey));
  return encidkey;
}

function decode_idkey(text) {
  var temp = atob(text);
  var decidkey = new Uint8Array(temp.length);
  for (i=0; i<temp.length; i+=1) {decidkey[i] = temp.charCodeAt(i);}
  return decidkey
}

function join_channel(channel) {
  ix = app.channelnames.indexOf(channel);
  if (ix == -1) {
    if (channel === "") {
      app.channelnames.unshift(channel);
      app.chatlogs.unshift([]);
    }
    else {
      app.channelnames.push(channel);
      app.chatlogs.push([]);
    }

    app.send_listen();
  }

  app.focuschannel = channel;
  inputfocus();
}

function leave_channel(channel) {
  ix = app.channelnames.indexOf(channel);
  if (ix != -1) {
    app.chatlogs.splice(ix, 1);
    app.channelnames.splice(ix, 1);

    app.send_listen();
  }
  if (app.focuschannel === channel) {
    app.changechannel(0);
  }
  inputfocus();
}

function post_message(channel, item) {
  ix = app.channelnames.indexOf(channel);
  if (ix != -1) {
    app.chatlogs[ix].push(item);

    update_icons();
    scrolldown();
  }
}

function update_icons() {
  Vue.nextTick(function () {
    jdenticon.update("svg");
  });
}

function scrolldown() {
  Vue.nextTick(function () {
    logdivs = document.getElementsByClassName("chatlog");
    for (var i=0 ; i<logdivs.length ; i+=1) {
      logdivs[i].scrollTop = logdivs[i].scrollHeight;
    }
  });
}

function inputfocus() {
  Vue.nextTick(function () {
    document.getElementById("input_text").focus();
  });
}
</script>
</head>

<body>

<div id="app">
<div class="login" v-bind:style="{display: state==='login' ? '' : 'none'}">
  <div class="unamepword">
    <h1>Hermod chat</h1>
    Username: <input ref="id_salt" v-model="self_user.id_salt" @keyup.enter="$refs.password.focus()"> <br/>
    Password: <input ref="password" v-model="self_user.password" @keyup.enter="$refs.calculatebutton.click()"> <br/>
    Your password would take {{crack_time}} to crack. <br/>
    <br/>
    <button ref="calculatebutton" onclick="calculate()">Calculate your IDKey</button>
  </div>
  <div id="calculate" v-bind:style="{display: idkey_state==='show' ? '' : 'none'}">
    Nickname: <input ref="nickname" v-model="self_user.nickname" @keyup.enter="$refs.connectbutton.click()"> <br/>
    IDKey:
    <svg width="128" height="128" v-bind:data-jdenticon-value="self_user.idkey"></svg> <br/>
    <br/>
    <button ref="connectbutton" onclick="connect()">Connect with this nickname and IDKey</button>
    <br/>
    {{sockmsg}}
  </div>
</div>

<div id="chat" v-bind:style="{display: state==='chat' ? '' : 'none'}">
  <button class="homebutton" v-on:click="join('')">&#x1f3e0;</button>
  <button class="newbutton" v-on:click="shownewdiv()">&#x1f4dd;</button>
  <div class="newdiv" v-bind:style="{display: newdiv_state==='show' ? '' : 'none'}">
    <input ref="newname" v-model="newchannelname" placeholder="New channel name" @keyup.enter="newchannel()" @keyup.escape="hidenewdiv()"></input>
  </div>
  <div id="logs">
    <div class="channel" v-for="(chatlog,ix) in chatlogs" v-on:click="changechannel(ix)" v-bind:class="{activechannel: focuschannel===channelnames[ix]}">
      <div class="channelname">
        <button class="leavebutton" v-on:click="leave(channelnames[ix], $event)">&#x274c;</button>
        <span v-if="channelnames[ix]===''" data-tooltip="CC 3.0 BY - Icon by Freepik https://www.flaticon.com/authors/freepik">
          <object data="home.svg" width=32 height=32></object>
        </span>
        <strong>{{channelnames[ix]}}</strong>
      </div>
      <div class="chatlog">
        <div class="msg" v-for="item in chatlog">
          <svg width="32" height="32" v-bind:data-jdenticon-value="item.idkey"></svg>
          <span class="timestamp">{{item.timestamp |fromNow}}</span>
          <p class="msgitem">
            <span class="msgtext">
              <strong>{{item.nickname}}:</strong>
              {{item.message}}
            </span>
          </p>
        </div>
      </div>
    </div>
  </div>
  <div id="who">
    <h3>Users here:</h3>
    <ul>
      <li v-for="(item,idkey) in users">
        <svg width="32" height="32" v-bind:data-jdenticon-value="idkey"></svg>
        <strong>{{item.nickname}}</strong>
      </li>
    </ul>
  </div>
  <div id="input">
    <svg width="64" height="64" v-bind:data-jdenticon-value="self_user.idkey"></svg>
    <strong>{{self_user.nickname}}:</strong>
    <textarea id="input_text" ref="input_text" v-model="input" @keydown.enter="send_say"></textarea>
  </div>
  <div class="sockmsg">
    {{sockmsg}}
  </div>
</div>
</div>

<script>
  var app = new Vue({
    el: '#app',
    data: {
      timestampinterval: null,
      checkuserinterval: null,
      state: "login",
      sockmsg: "",
      idkey_state: "hide",
      newdiv_state: "hide",
      websocket: null,
      self_user: {
        id_salt: "",
        password: "",
        privkey: "",
        idkey: "",
        nickname: "",
      },
      users: {},
      channelusers: {},
      channelnames: [],
      focuschannel: "",
      chatlogs: [],
      newchannelname: "",
      input: "",
      signsend: function (payloadobj) {
        var encidkey = encode_idkey(this.self_user.idkey);
        var obj = {idkey: encidkey, payload: JSON.stringify(payloadobj)};
        this.websocket.send(JSON.stringify(obj));
      },
      send_say: function (e) {
        e.preventDefault();
        if (this.input === "") {return;}

        var sayobj = {} ; sayobj[this.focuschannel] = this.input;
        var payloadobj = {timestamp: moment().utc().format(),
                          nickname: this.self_user.nickname,
                          say: sayobj};

        this.signsend(payloadobj);

        // TODO don't erase input box unless/until message sent
        this.input = "";
      },
      send_listen: function () {
        var payloadobj = {timestamp:moment().utc().format(),
                          nickname: this.self_user.nickname,
                          listen: this.channelnames};
        this.signsend(payloadobj);
      },
      send_who: function () {
        var payloadobj = {timestamp:moment().utc().format(),
                          who: "*"};
        this.signsend(payloadobj);
      },
      send_call: function(youridkey) {
        var payloadobj = {timestamp:moment().utc().format(),
                          call: encode_idkey(youridkey)};
        this.signsend(payloadobj);
      },
      changechannel: function (ix) {
        app.focuschannel = app.channelnames[ix];
        inputfocus();
      },
      join: function (channel) {
        join_channel(channel);
      },
      leave: function (channel, e) {
        e.stopPropagation();
        leave_channel(channel);
      },
      shownewdiv: function() {
        this.newdiv_state = "show";
        Vue.nextTick(function () {
          app.$refs.newname.focus();
        });
      },
      hidenewdiv: function() {
        this.newchannelname = "";
        this.newdiv_state = "hide";
        inputfocus();
      },
      newchannel: function() {
        this.join(this.newchannelname);
        this.newchannelname = "";
        this.newdiv_state = "hide";
      },
      checkusers: function() {
        var now = moment();
        for (var youridkey in this.users) {
          //TODO log youridkey to find out how it gets hosed
          var user = this.users[youridkey];
          if (now - user.lastseen > 60000) {
            // no word for 1 minute, they're gone
            delete this.users[youridkey];
          }
          else if (now - user.lastcalled > 30000) {
            // no word for 30 seconds, try calling
            Vue.nextTick(function () {
              app.send_call(youridkey);
            });
          }
        }
      },
    },
    created: function () {
      this.timestampinterval = setInterval(() => this.$forceUpdate(), 60000);
      this.checkuserinterval = setInterval(() => this.checkusers(), 10000);
    },
    mounted: function () {
      this.$refs.id_salt.focus();
    },
    beforeDestroy() {
      clearInterval(this.timestampinterval);
      clearInterval(this.checkuserinterval);
    },
    computed: {
      crack_time: function() {
        return zxcvbn(this.self_user.password).crack_times_display.offline_slow_hashing_1e4_per_second;
      },
    },
    filters: {
      fromNow(date) {
        return moment(date).fromNow();
      },
    },
  });
</script>

</body>
</html>
