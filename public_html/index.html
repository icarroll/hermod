<html>
<!--
TODO:
track channels and membership more closely
auto-link urls
auto-reconnect attempt
hide password button
tooltips on home and add buttons
hints for vue for channel join/leave
control-enter for newline in chat
trim text, don't send pure whitespace
scroll to bottom on size change
allow copy of chat text
figure out channel membership for multiple login

attach signature
verify signature
verify timestamp
time sync
-->
<head>
  <link type="text/css" rel="stylesheet" href="bootstrap.min.css"/>
  <link type="text/css" rel="stylesheet" href="bootstrap-vue.css"/>

  <!-- <script src="vue.min.js"></script> -->
  <script src="vue.js"></script>
  <script src="bootstrap-vue.js"></script>

  <script src="jdenticon.min.js"></script>
  <script>
    window.jdenticon_config = {
      lightness: {
        color: [0.33, 0.67],
        grayscale: [0.17, 0.67],
      },
      saturation: {
        color: 1.0,
        grayscale: 0.0,
      },
      backColor: "#ffffff"
    };
  </script>

  <script src="sodium.js"></script>
  <script src="zxcvbn.js"></script>

  <script src="moment.js"></script>
  <script src="moment-timezone-with-data.js"></script>

<style>
[v-cloak] {
  display: none;
}

.login {
  height: 100%;
  display: grid;
  grid-template-columns: 1fr 2fr 1fr;
  grid-template-rows: 1fr 2fr 2fr 1fr;
}

.unamepword {
  grid-column: 2;
  grid-row: 2;
}

.calculate {
  grid-column: 2;
  grid-row: 3;
}

.chat {
  height: 100%;
  display: grid;
  grid-template-columns: 80% 20%;
  grid-template-rows: 85% 15%;
}

.navbuttons {
  position: absolute;
  z-index: 2;
  top: 0;
  right: 20%;
}

.navbuttons button {
  background: white;
}

.newdiv {
  position: absolute;
  right: 0;
}

svg {
  border: 1px solid black;
}

svg.nob {
  border: none;
}

button:hover svg {
  fill: white;
}

#logs {
  grid-column: 1;
  grid-row: 1;

  display: flex;
  flex-direction: row;
}

.closebtn svg {
  fill: red;
  border-radius: 7px;
}

.closebtn:hover svg {
  fill: white;
  background: red;
}

.channel {
  opacity: 0.5;

  width: 0;
  flex-basis: 0;
  flex-grow: 1;
  border-left: 1px solid black;

  display: flex;
  flex-direction: column;
}

.channel:first-child {
  border-left: none;
}

.channel.activechannel {
  opacity: 1;
}

.channelname {
  flex-basis: auto;
  flex-grow: 0;
  border-bottom: 1px solid black;
  margin-bottom: 5px;
  white-space: nowrap;
  overflow-x: hidden;
  text-overflow: ellipsis;
}

.activechannel .channelname {
  box-shadow: 0 5px blue;
}

.chatlog {
  flex-basis: 0;
  flex-grow: 1;
  overflow-y: scroll;
}

.chatlog div::after {
  /* clearfix hack */
  content: "";
  clear: both;
  display: table;
}

.msg {
  background: #f7f7f7;
  margin: 5px;
  border: 1px solid lightgrey;
}

.msg svg {
  float: left;
}

.msgitem {
  margin-left: 42px;
  margin-block-end: 0;
}

.msgtext {
  word-break: break-word;
}

.timestamp {
  font-style: italic;
  font-size: small;
  color: grey;
  float: right;
  border-left: 1px solid lightgrey;
  border-bottom: 1px solid lightgrey;
  padding-left: 3px;
  padding-right: 3px;
}

#lists {
  grid-column: 2;
  grid-row: 1 / span 2;

  padding-left: 10px;
  border-left: 1px solid black;

  display: flex;
  flex-direction: column;
}

#who {
  overflow-y: scroll;

  flex-basis: 0;
  flex-grow: 1;
}

#who ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

#who li {
  margin-bottom: 5px;
  white-space: nowrap;
  overflow-x: hidden;
  text-overflow: ellipsis;
}

#where {
  overflow-y: scroll;

  flex-basis: 0;
  flex-grow: 1;
}

#where ul {
  margin: 0;
  margin-right: 10px;
  overflow-x: hidden;
}

#where li {
  cursor: pointer;
  white-space: nowrap;
}

#where li:hover {
  background: #f0f0f0;
}

.chnadd {
  visibility: hidden;
}

li:hover .chnadd {
  visibility: visible;
}

textarea {
  resize: none;
}

#input {
  padding-top: 10px;
  padding-bottom: 10px;
  grid-column: 1;
  grid-row: 2;

  border-top: 1px solid black;

  display: grid;
  grid-template-columns: auto auto 1fr;
}

#input strong {
  padding-left: 10px;
  padding-right: 10px;
}

.sockmsg {
  position: absolute;
  bottom: 0;
  left: 0;
}
</style>

<script>
function calculate() {
  app.idkey_state = "show";

  app.self_user.nickname = app.self_user.id_salt;

  seed = sodium.crypto_pwhash(32, app.self_user.password, sodium.crypto_generichash(16, app.self_user.id_salt), 12, 10000000, sodium.crypto_pwhash_ALG_ARGON2ID13)
  keypair = sodium.crypto_sign_seed_keypair(seed);
  app.self_user.privkey = keypair.privateKey;
  app.self_user.idkey = keypair.publicKey;

  update_icons();
  Vue.nextTick(function () {
    app.$refs.nickname.focus();
  });
}

function connect() {
  // app.websocket = new WebSocket("ws://" + window.location.host + ":8192" + window.location.pathname.substring(0, window.location.pathname.lastIndexOf("/")) + "/chatsock");
  // app.websocket = new WebSocket("ws://" + window.location.host + ":8192" + "/chatsock");
  app.sockmsg = "Connecting...";

  app.websocket = new WebSocket("ws://ada.cs.pdx.edu:8192/")

  app.websocket.onmessage = function (e) {
    var receive = JSON.parse(e.data);

    if (! ("idkey" in receive)) {console.log("no idkey"); return;}
    var decidkey = decode_idkey(receive.idkey);

    if (! ("payload" in receive)) {console.log("no payload"); return;}
    //TODO verify signature
    var payload = JSON.parse(receive.payload);

    if (! ("timestamp" in payload)) {console.log("no timestamp"); return;}
    //TODO verify timestamp

    if (! (decidkey in app.users)) {
      //TODO recognize own idkey
      app.users[decidkey] = {nickname: "", listening: []};
      app.$forceUpdate();
      update_icons();
    }

    app.users[decidkey].lastseen = moment();
    app.users[decidkey].lastcalled = moment();

    if ("who" in payload) {
      //TODO don't respond to own who
      Vue.nextTick(function () {
        app.send_listen();
      });
    }

    if ("call" in payload) {
      var youridkey = decode_idkey(payload.call);
      if (youridkey === app.self_user.idkey) {
        Vue.nextTick(function () {
          app.send_listen();
        });
      }
      else if (youridkey in app.users) {
        app.users[youridkey].lastcalled = moment();
      }
    }

    if ("listen" in payload) {
      //TODO sanity check payload.listen
      //TODO update channel member lists
      app.users[decidkey].listening = payload.listen;
    }

    if ("nickname" in payload) {
      app.users[decidkey].nickname = payload.nickname;
    }

    if ("say" in payload) {
      for (var channel in payload.say) {
        item = {idkey: decidkey,
                nickname: app.users[decidkey].nickname,
                message: payload.say[channel],
                timestamp: payload.timestamp};
        post_message(channel, item)
      }
    }
  }

  app.websocket.onopen = function (e) {
    var encidkey = btoa(String.fromCharCode(...app.self_user.idkey));
    var obj = {idkey:encidkey, nickname:app.self_user.nickname, join:[""]};
    // app.websocket.send(JSON.stringify(obj));

    app.sockmsg = "Connected";
    app.state="chat";

    window.onbeforeunload = function() {return true;};
    app.join("");
    app.send_who();
  }

  app.websocket.onclose = function (e) {
    app.sockmsg = "Not Connected";
  }
}

function encode_idkey(idkey) {
  var encidkey = btoa(String.fromCharCode(...idkey));
  return encidkey;
}

function decode_idkey(text) {
  var temp = atob(text);
  var decidkey = new Uint8Array(temp.length);
  for (i=0; i<temp.length; i+=1) {decidkey[i] = temp.charCodeAt(i);}
  return decidkey
}

function join_channel(channel) {
  if (typeof channel != "string") {channel = "";}

  ix = app.mychannelnames.indexOf(channel);
  if (ix == -1) {
    if (channel === "") {
      app.mychannelnames.unshift(channel);
      app.chatlogs.unshift([]);
    }
    else {
      app.mychannelnames.push(channel);
      app.chatlogs.push([]);
    }

    app.send_listen();
  }

  app.focuschannel = channel;
  inputfocus();
}

function leave_channel(channel) {
  ix = app.mychannelnames.indexOf(channel);
  if (ix != -1) {
    app.chatlogs.splice(ix, 1);
    app.mychannelnames.splice(ix, 1);

    app.send_listen();
  }
  if (app.focuschannel === channel) {
    app.changechannel(0);
  }
  inputfocus();
}

function post_message(channel, item) {
  ix = app.mychannelnames.indexOf(channel);
  if (ix != -1) {
    app.chatlogs[ix].push(item);

    update_icons();
    scrolldown();
  }
}

function update_icons() {
  Vue.nextTick(function () {
    jdenticon.update("svg");
  });
}

function scrolldown() {
  Vue.nextTick(function () {
    logdivs = document.getElementsByClassName("chatlog");
    for (var i=0 ; i<logdivs.length ; i+=1) {
      logdivs[i].scrollTop = logdivs[i].scrollHeight;
    }
  });
}

function inputfocus() {
  //TODO allow copy-paste
  Vue.nextTick(function () {
    document.getElementById("input_text").focus();
  });
}
</script>
</head>

<body>

<div id="app">
<div class="login" v-show="state==='login'">
  <div class="unamepword">
    <b-card title="Hermod chat">
      <b-input-group prepend="Username:">
        <b-form-input ref="id_salt" v-model="self_user.id_salt" @keyup.enter.native="$refs.password.focus()"></b-form-input>
      </b-input-group>
      <b-input-group prepend="Password:">
        <b-form-input ref="password" v-model="self_user.password" @keyup.enter.native="$refs.calculatebutton.click()"></b-form-input>
      </b-input-group>
      Your password would take {{crack_time}} to crack.
      <br/>
      <b-button variant="outline-primary" ref="calculatebutton" onclick="calculate()">Calculate your IDKey</b-button>
    </b-card>
  </div>

  <div class="calculate" v-show="idkey_state==='show'" v-cloak>
    <b-card>
      <b-input-group prepend="Nickname:">
        <b-form-input ref="nickname" v-model="self_user.nickname" @keyup.enter.native="$refs.connectbutton.click()"></b-form-input>
      </b-input-group>
      IDKey:
      <svg width="128" height="128" v-bind:data-jdenticon-value="self_user.idkey"></svg>
      <br/>
      <b-button variant="outline-primary" ref="connectbutton" onclick="connect()">Connect with this nickname and IDKey</b-button>
      <br/>
      {{sockmsg}}
    </b-card>
  </div>
</div>

<div class="chat" v-show="state==='chat'" v-cloak>
  <div class="navbuttons">
    <b-button variant="outline-secondary" onclick="app.join('')">
      <svg class="nob" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 48 48"><path d="M20 40V28h8v12h10V24h6L24 6 4 24h6v16z"/></svg>
    </b-button>
    <b-button variant="outline-secondary" onclick="app.shownewdiv()">
      <svg class="nob" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 48 48"><path d="M38 26H26v12h-4V26H10v-4h12V10h4v12h12v4z"/></svg>
    </b-button>
    <div class="newdiv" v-show="newdiv_state==='show'">
      <b-input style="width: auto;" ref="newname" v-model="newchannelname" placeholder="New channel name" @keyup.enter.native="newchannel()" @keyup.escape.native="hidenewdiv()" v-on:blur.native="hidenewdiv()"></input>
    </div>
  </div>

  <div id="logs">
    <div class="channel" v-for="(chatlog,ix) in chatlogs" v-on:click="changechannel(ix)" v-bind:class="{activechannel: focuschannel===mychannelnames[ix]}">
      <div class="channelname">
        <span class="closebtn" v-on:click="leave(mychannelnames[ix], $event)">
          <svg class="nob" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 48 48"><path d="M38 12.83L35.17 10 24 21.17 12.83 10 10 12.83 21.17 24 10 35.17 12.83 38 24 26.83 35.17 38 38 35.17 26.83 24z"/></svg>
        </span>
        <span v-if="mychannelnames[ix]===''">
          <img width="36" height="36" src="Small_SVG_house_icon.svg"/>
        </span>
        <strong style="line-height: 36px;">{{mychannelnames[ix]}}</strong>
      </div>
      <div class="chatlog">
        <div class="msg" v-for="item in chatlog">
          <svg width="32" height="32" v-bind:data-jdenticon-value="item.idkey"></svg>
          <span class="timestamp">{{item.timestamp |fromNow}}</span>
          <p class="msgitem">
            <span class="msgtext">
              <strong>{{item.nickname}}:</strong>
              {{item.message}}
            </span>
          </p>
        </div>
      </div>
    </div>
  </div>

  <div id="lists">
    <strong>Channel Members:</strong>
    <div id="who">
      <ul>
        <li v-for="idkey in sorted_channel_users">
          <svg width="32" height="32" v-bind:data-jdenticon-value="idkey"></svg>
          <strong>{{users[idkey].nickname}}</strong>
        </li>
      </ul>
    </div>

    <hr style="width: 100%;" />

    <strong>Active Channels:</strong>
    <div id="where">
      <ul class="list-group">
        <li class="list-group-item" v-for="item in sorted_channels" @click="join(item)">
          <strong>{{item}}</strong>
          <span v-if="item===''">
            <!--
            <svg class="nob" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 48 48"><path d="M20 40V28h8v12h10V24h6L24 6 4 24h6v16z"/></svg>
            -->
            <img width="18" height="18" src="Small_SVG_house_icon.svg"/>
          </span>
          <svg class="nob chnadd" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 48 48"><path d="M38 26H26v12h-4V26H10v-4h12V10h4v12h12v4z"/></svg>
        </li>
      </ul>
    </div>
  </div>
  <div id="input" class="container-fluid">
    <svg width="64" height="64" v-bind:data-jdenticon-value="self_user.idkey"></svg>
    <strong>{{self_user.nickname}}:</strong>
    <b-form-textarea id="input_text" ref="input_text" v-model="input" @keydown.enter.native="send_say"></textarea>
  </div>
  <div class="sockmsg">
    {{sockmsg}}
  </div>
</div>
</div>

<script>
  var app = new Vue({
    el: '#app',
    data: {
      timestampinterval: null,
      checkuserinterval: null,
      state: "login",
      sockmsg: "",
      idkey_state: "hide",
      newdiv_state: "hide",
      websocket: null,
      self_user: {
        id_salt: "",
        password: "",
        privkey: "",
        idkey: "",
        nickname: "",
      },
      users: {},
      channelusers: {},
      mychannelnames: [],
      focuschannel: "",
      chatlogs: [],
      newchannelname: "",
      input: "",
      signsend: function (payloadobj) {
        var encidkey = encode_idkey(this.self_user.idkey);
        var obj = {idkey: encidkey, payload: JSON.stringify(payloadobj)};
        this.websocket.send(JSON.stringify(obj));
      },
      send_say: function (e) {
        e.preventDefault();
        if (this.input === "") {return;}

        var sayobj = {} ; sayobj[this.focuschannel] = this.input;
        var payloadobj = {timestamp: moment().utc().format(),
                          nickname: this.self_user.nickname,
                          say: sayobj};

        this.signsend(payloadobj);

        // TODO don't erase input box unless/until message sent
        this.input = "";
      },
      send_listen: function () {
        var payloadobj = {timestamp:moment().utc().format(),
                          nickname: this.self_user.nickname,
                          listen: this.mychannelnames};
        this.signsend(payloadobj);
      },
      send_who: function () {
        var payloadobj = {timestamp:moment().utc().format(),
                          who: "*"};
        this.signsend(payloadobj);
      },
      send_call: function(youridkey) {
        var payloadobj = {timestamp:moment().utc().format(),
                          call: encode_idkey(youridkey)};
        this.signsend(payloadobj);
      },
      changechannel: function (ix) {
        this.checkusers();
        app.focuschannel = app.mychannelnames[ix];
        inputfocus();
      },
      join: function (channel) {
        join_channel(channel);
      },
      leave: function (channel, e) {
        e.stopPropagation();
        leave_channel(channel);
      },
      shownewdiv: function() {
        this.newdiv_state = "show";
        Vue.nextTick(function () {
          app.$refs.newname.focus();
        });
      },
      hidenewdiv: function() {
        this.newchannelname = "";
        this.newdiv_state = "hide";
        inputfocus();
      },
      newchannel: function() {
        this.join(this.newchannelname);
        this.newchannelname = "";
        this.newdiv_state = "hide";
      },
      checkusers: function() {
        var now = moment();
        this.channelusers = {};

        for (var youridkey in this.users) {
          //TODO log youridkey to find out how it gets hosed
          var user = this.users[youridkey];
          if (now - user.lastseen > 60000) {
            // no word for 1 minute, they're gone
            delete this.users[youridkey];
            continue;
          }
          else if (now - user.lastcalled > 30000) {
            // no word for 30 seconds, try calling
            Vue.nextTick(function () {
              app.send_call(youridkey);
            });
          }

          // if user is still around, record channel membership
          var listening = this.users[youridkey].listening;
          for (var ix in listening) {
            if (listening[ix] in this.channelusers) {
            }
            else {
              Vue.set(this.channelusers, listening[ix], {});
            }
            Vue.set(this.channelusers[listening[ix]], youridkey, true);
          }
        }

        this.$forceUpdate();
        update_icons();
      },
    },
    created: function () {
      this.timestampinterval = setInterval(() => this.$forceUpdate(), 60000);
      this.checkuserinterval = setInterval(() => this.checkusers(), 10000);
    },
    mounted: function () {
      this.$refs.id_salt.focus();
    },
    beforeDestroy() {
      clearInterval(this.timestampinterval);
      clearInterval(this.checkuserinterval);
    },
    computed: {
      crack_time: function () {
        return zxcvbn(this.self_user.password).crack_times_display.offline_slow_hashing_1e4_per_second;
      },
      sorted_channel_users: function () {
        if (! (this.focuschannel in this.channelusers)) {return new Array();}

        var temp = Object.keys(this.channelusers[this.focuschannel]);
        temp.sort();
        return temp;
      },
      sorted_channels: function () {
        var temp = Object.keys(this.channelusers);
        temp.sort();
        return temp;
      },
    },
    filters: {
      fromNow(date) {
        return moment(date).fromNow();
      },
    },
  });
</script>

</body>
</html>
