<html>
<!--
TODO:
auto-reconnect attempt
hide password button
tooltips on home and add buttons
hints for vue for channel join/leave
control-enter for newline in chat
scroll to bottom on size change
figure out channel membership for multiple login

verify timestamp
time sync
-->
<head>
  <link type="text/css" rel="stylesheet" href="bootstrap.min.css"/>
  <link type="text/css" rel="stylesheet" href="bootstrap-vue.css"/>

  <!-- <script src="vue.min.js"></script> -->
  <script src="vue.js"></script>
  <script src="bootstrap-vue.js"></script>

  <script src="jdenticon.min.js"></script>
  <script>
    window.jdenticon_config = {
      lightness: {
        color: [0.33, 0.67],
        grayscale: [0.17, 0.67],
      },
      saturation: {
        color: 1.0,
        grayscale: 0.0,
      },
      backColor: "#ffffff"
    };
  </script>

  <script src="sodium.js"></script>
  <script src="zxcvbn.js"></script>

  <script src="moment.js"></script>
  <script src="moment-timezone-with-data.js"></script>

<style>
[v-cloak] {
  display: none;
}

.login {
  height: 100%;
  display: grid;
  grid-template-columns: 1fr 2fr 1fr;
  grid-template-rows: 1fr 2fr 2fr 1fr;
}

.unamepword {
  grid-column: 2;
  grid-row: 2;
}

.calculate {
  grid-column: 2;
  grid-row: 3;
}

.chat {
  height: 100%;
  display: grid;
  grid-template-columns: 80% 20%;
  grid-template-rows: 85% 15%;
}

.navbuttons {
  position: absolute;
  z-index: 2;
  top: 0;
  right: 20%;
}

.navbuttons button {
  background: white;
}

.newdiv {
  position: absolute;
  right: 0;
}

svg {
  border: 1px solid black;
}

svg.nob {
  border: none;
}

button:hover svg {
  fill: white;
}

#logs {
  grid-column: 1;
  grid-row: 1;

  display: flex;
  flex-direction: row;
}

.closebtn svg {
  fill: red;
  border-radius: 7px;
}

.closebtn:hover svg {
  fill: white;
  background: red;
}

.channel {
  opacity: 0.5;

  width: 0;
  flex-basis: 0;
  flex-grow: 1;
  border-left: 1px solid black;

  display: flex;
  flex-direction: column;
}

.channel:first-child {
  border-left: none;
}

.channel.activechannel {
  opacity: 1;
}

.channelname {
  flex-basis: auto;
  flex-grow: 0;
  border-bottom: 1px solid black;
  margin-bottom: 5px;
  white-space: nowrap;
  overflow-x: hidden;
  text-overflow: ellipsis;
}

.activechannel .channelname {
  box-shadow: 0 5px blue;
}

.chatlog {
  flex-basis: 0;
  flex-grow: 1;
  overflow-y: scroll;
}

.chatlog div::after {
  /* clearfix hack */
  content: "";
  clear: both;
  display: table;
}

.msg {
  background: #f7f7f7;
  margin: 5px;
  border: 1px solid lightgrey;
}

.msg svg {
  float: left;
}

.msgitem {
  margin-left: 42px;
  margin-block-end: 0;
}

.msgtext {
  word-break: break-word;
}

.timestamp {
  font-style: italic;
  font-size: small;
  color: grey;
  float: right;
  border-left: 1px solid lightgrey;
  border-bottom: 1px solid lightgrey;
  padding-left: 3px;
  padding-right: 3px;
  margin-left: 5px;
}

#lists {
  grid-column: 2;
  grid-row: 1 / span 2;

  padding-left: 10px;
  border-left: 1px solid black;

  display: flex;
  flex-direction: column;
}

#who {
  overflow-y: scroll;

  flex-basis: 0;
  flex-grow: 1;
}

#who ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

#who li {
  margin-bottom: 5px;
  white-space: nowrap;
  overflow-x: hidden;
  text-overflow: ellipsis;
}

#where {
  overflow-y: scroll;

  flex-basis: 0;
  flex-grow: 1;
}

#where ul {
  margin: 0;
  margin-right: 10px;
  overflow-x: hidden;
}

#where li {
  cursor: pointer;
  white-space: nowrap;
}

#where li:hover {
  background: #f0f0f0;
}

.chnadd {
  visibility: hidden;
}

li:hover .chnadd {
  visibility: visible;
}

textarea {
  resize: none;
}

#input {
  padding-top: 10px;
  padding-bottom: 10px;
  grid-column: 1;
  grid-row: 2;

  border-top: 1px solid black;

  display: grid;
  grid-template-columns: auto auto 1fr;
}

#input strong {
  padding-left: 10px;
  padding-right: 10px;
}

span.sockstate {
  position: absolute;
  bottom: 10px;
  right: 10px;
}

div.sockstate {
  position: absolute;
  bottom: 10px;
  left: 10px;
}
</style>

<script>
function calculate() {
  app.idkey_state = "show";

  app.self_user.nickname = app.self_user.id_salt;

  seed = sodium.crypto_pwhash(32, app.self_user.password, sodium.crypto_generichash(16, app.self_user.id_salt), 12, 10000000, sodium.crypto_pwhash_ALG_ARGON2ID13)
  keypair = sodium.crypto_sign_seed_keypair(seed);
  app.self_user.privkey = keypair.privateKey;
  app.self_user.idkey = keypair.publicKey;

  update_icons();
  Vue.nextTick(function () {
    app.$refs.nickname.focus();
  });
}

function connect() {
  // app.websocket = new WebSocket("ws://" + window.location.host + ":8192" + window.location.pathname.substring(0, window.location.pathname.lastIndexOf("/")) + "/chatsock");
  // app.websocket = new WebSocket("ws://" + window.location.host + ":8192" + "/chatsock");
  app.sockstate = "connecting";

  app.websocket = new WebSocket("ws://ada.cs.pdx.edu:8192/")

  app.websocket.onmessage = function (e) {
    var receive = JSON.parse(e.data);

    if ("advise_disconnect" in receive) {
      delete app.users[receive.advise_disconnect];
      app.checkusers(); //TODO only update the one client
      return;
    }

    if (! ("idkey" in receive)) {console.log("no idkey"); return;}
    var encidkey = receive.idkey;
    var decidkey = decode_base64(encidkey);

    if (! ("payload" in receive)) {console.log("no payload"); return;}
    var signature = decode_base64(receive.signature);
    if (! sodium.crypto_sign_verify_detached(signature, receive.payload, decidkey)) {console.log("didn't match") ; return;}
    var payload = JSON.parse(receive.payload);

    if (! ("timestamp" in payload)) {console.log("no timestamp"); return;}
    //TODO verify timestamp
    /*
    var then_t = moment(payload.timestamp);
    var now_t = moment().utc();
    console.log(then_t.format(), now_t.format(), now_t - then_t)
    */

    if (! (encidkey in app.users)) {
      //TODO recognize own idkey (?)
      app.users[encidkey] = {nickname: "", listening: [], idle: false};
      app.$forceUpdate();
      update_icons();
    }

    app.users[encidkey].lastseen = moment();

    if ("who" in payload) {
      // yes, reply to my own who
      app.lastwho = moment();
      Vue.nextTick(function () {
        console.log("got who, sending listen");
        app.send_listen();
      });
    }

    if ("listen" in payload) {
      //TODO sanity check payload.listen
      //TODO update channel member lists
      app.users[encidkey].listening = payload.listen;
      app.checkusers(); //TODO only update the one client
    }

    if ("nickname" in payload) {
      app.users[encidkey].nickname = payload.nickname;
    }

    if ("idle" in payload) {
      app.users[encidkey].idle = payload.idle;
    }

    if ("say" in payload) {
      app.users[encidkey].idle = false;
      for (var channel in payload.say) {
        item = {idkey: encidkey,
                nickname: app.users[encidkey].nickname,
                message: safelink(payload.say[channel]),
                timestamp: payload.timestamp};
        post_message(channel, item)
      }
    }
  }

  app.websocket.onopen = function (e) {
    app.sockstate = "connected";
    app.state="chat";

    window.onbeforeunload = function() {return true;};
    app.join("");
    app.send_who();

    app.checkusers();
  }

  app.websocket.onclose = function (e) {
    app.sockstate = "notconnected";
  }

  app.websocket.onerror = function (e) {
    app.sockstate = "notconnected";
  }
}

function encode_base64(text) {
  var code = btoa(String.fromCharCode(...text));
  return code;
}

function decode_base64(code) {
  var temp = atob(code);
  var text = new Uint8Array(temp.length);
  for (i=0; i<temp.length; i+=1) {text[i] = temp.charCodeAt(i);}
  return text
}

function join_channel(channel) {
  if (typeof channel != "string") {channel = "";}

  ix = app.mychannelnames.indexOf(channel);
  if (ix == -1) {
    if (channel === "") {
      app.mychannelnames.unshift(channel);
      app.chatlogs.unshift([]);
    }
    else {
      app.mychannelnames.push(channel);
      app.chatlogs.push([]);
    }

    console.log("joined channel, sending listen");
    app.send_listen();
  }

  app.focuschannel = channel;
  app.checkusers(); //TODO only update the one client
  inputfocus();
}

function leave_channel(channel) {
  ix = app.mychannelnames.indexOf(channel);
  if (ix != -1) {
    app.chatlogs.splice(ix, 1);
    app.mychannelnames.splice(ix, 1);

    console.log("left channel, sending listen");
    app.send_listen();
  }
  if (app.focuschannel === channel) {
    app.changechannel(0);
  }
  app.checkusers(); //TODO only update the one client
  inputfocus();
}

function post_message(channel, item) {
  ix = app.mychannelnames.indexOf(channel);
  if (ix != -1) {
    app.chatlogs[ix].push(item);

    update_icons();
    scrolldown();
  }
}

function safelink(text) {
  urlpat = /(https?:\/\/\S+)/;
  var parts = text.split(urlpat);

  var plaintext = parts.shift();
  var temp = document.createElement("span");
  temp.textContent = plaintext;
  safetext = temp.innerHTML;

  while (parts.length > 0) {
    var linktext = parts.shift();
    var temp = document.createElement("a");
    temp.href = linktext;
    temp.innerText = linktext;
    temp.target = "_blank";
    safetext += temp.outerHTML;

    var plaintext = parts.shift();
    var temp = document.createElement("span");
    temp.textContent = plaintext;
    safetext += temp.innerHTML;
  }

  return safetext;
}

function update_icons() {
  Vue.nextTick(function () {
    jdenticon.update("svg");
  });
}

function scrolldown() {
  Vue.nextTick(function () {
    logdivs = document.getElementsByClassName("chatlog");
    for (var i=0 ; i<logdivs.length ; i+=1) {
      logdivs[i].scrollTop = logdivs[i].scrollHeight;
    }
  });
}

function inputfocus() {
  //TODO allow copy-paste
  Vue.nextTick(function () {
    document.getElementById("input_text").focus();
  });
}
</script>
</head>

<body>

<div id="app">
<div class="login" v-show="state==='login'">
  <div class="unamepword">
    <b-card title="Hermod chat">
      <b-input-group prepend="Username:">
        <b-form-input ref="id_salt" v-model="self_user.id_salt" @keyup.enter.native="$refs.password.focus()"></b-form-input>
      </b-input-group>
      <b-input-group prepend="Password:">
        <b-form-input ref="password" v-model="self_user.password" @keyup.enter.native="$refs.calculatebutton.click()"></b-form-input>
      </b-input-group>
      Your password would take {{crack_time}} to crack.
      <br/>
      <b-button variant="outline-primary" ref="calculatebutton" onclick="calculate()">Calculate your IDKey</b-button>
    </b-card>
  </div>

  <div class="calculate" v-show="idkey_state==='show'" v-cloak>
    <b-card>
      <b-input-group prepend="Nickname:">
        <b-form-input ref="nickname" v-model="self_user.nickname" @keyup.enter.native="$refs.connectbutton.click()"></b-form-input>
      </b-input-group>
      IDKey:
      <svg width="128" height="128" v-bind:data-jdenticon-value="idkey_base64"></svg>
      <br/>
      <b-button variant="outline-primary" ref="connectbutton" onclick="connect()">Connect with this nickname and IDKey</b-button>
      <span class="sockstate" v-bind:style="{color: sockstatecolor}">{{sockstatetext}}</span>
    </b-card>
  </div>
</div>

<div class="chat" v-show="state==='chat'" v-cloak>
  <div class="navbuttons">
    <b-button variant="outline-secondary" onclick="app.join('')">
      <svg class="nob" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 48 48"><path d="M20 40V28h8v12h10V24h6L24 6 4 24h6v16z"/></svg>
    </b-button>
    <b-button variant="outline-secondary" onclick="app.shownewdiv()">
      <svg class="nob" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 48 48"><path d="M38 26H26v12h-4V26H10v-4h12V10h4v12h12v4z"/></svg>
    </b-button>
    <div class="newdiv" v-show="newdiv_state==='show'">
      <b-input style="width: auto;" ref="newname" v-model="newchannelname" placeholder="New channel name" @keyup.enter.native="newchannel()" @keyup.escape.native="hidenewdiv()" v-on:blur.native="hidenewdiv()"></input>
    </div>
  </div>

  <div id="logs">
    <div class="channel" v-for="(chatlog,ix) in chatlogs" v-on:click="changechannel(ix)" v-bind:class="{activechannel: focuschannel===mychannelnames[ix]}">
      <div class="channelname">
        <span class="closebtn" v-on:click="leave(mychannelnames[ix], $event)">
          <svg class="nob" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 48 48"><path d="M38 12.83L35.17 10 24 21.17 12.83 10 10 12.83 21.17 24 10 35.17 12.83 38 24 26.83 35.17 38 38 35.17 26.83 24z"/></svg>
        </span>
        <span v-if="mychannelnames[ix]===''">
          <img width="36" height="36" src="Small_SVG_house_icon.svg"/>
        </span>
        <strong style="line-height: 36px;">{{mychannelnames[ix]}}</strong>
      </div>
      <div class="chatlog">
        <div class="msg" v-for="item in chatlog">
          <svg width="32" height="32" v-bind:data-jdenticon-value="item.idkey"></svg>
          <span class="timestamp">{{item.timestamp |fromNow}}</span>
          <p class="msgitem">
            <span class="msgtext">
              <strong>{{item.nickname}}:</strong>
              <span v-html="item.message"></span>
              <!-- {{item.message}} -->
            </span>
          </p>
        </div>
      </div>
    </div>
  </div>

  <div id="lists">
    <strong>Channel Members:</strong>
    <div id="who">
      <ul>
        <li v-for="idkey in sorted_channel_users">
          <svg width="32" height="32" v-bind:data-jdenticon-value="idkey"></svg>
          <img width="18" height="18" v-if="users[idkey].idle" src="zzz.png"/>
          <strong>{{users[idkey].nickname}}</strong>
        </li>
      </ul>
    </div>

    <hr style="width: 100%;" />

    <strong>Active Channels:</strong>
    <div id="where">
      <ul class="list-group">
        <li class="list-group-item" v-for="item in sorted_channels" @click="join(item)">
          <strong>{{item}}</strong>
          <span v-if="item===''">
            <!--
            <svg class="nob" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 48 48"><path d="M20 40V28h8v12h10V24h6L24 6 4 24h6v16z"/></svg>
            -->
            <img width="18" height="18" src="Small_SVG_house_icon.svg"/>
          </span>
          <svg class="nob chnadd" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 48 48"><path d="M38 26H26v12h-4V26H10v-4h12V10h4v12h12v4z"/></svg>
        </li>
      </ul>
    </div>
  </div>
  <div id="input" class="container-fluid">
    <svg width="64" height="64" v-bind:data-jdenticon-value="idkey_base64"></svg>
    <strong>{{self_user.nickname}}:</strong>
    <b-form-textarea id="input_text" ref="input_text" v-model="input" @keydown.enter.native="send_say"></textarea>
  </div>
  <div class="sockstate" v-bind:style="{color: sockstatecolor}">{{sockstatetext}}</div>
</div>
</div>

<script>
  var app = new Vue({
    el: '#app',
    data: {
      idletimeout: 300000,   // 5 minutes in milliseconds
      timestampinterval: null,
      checkuserinterval: null,
      lastwho: moment(),
      lastsay: moment(),
      state: "login",
      sockstate: "notconnected",
      idkey_state: "hide",
      newdiv_state: "hide",
      websocket: null,
      self_user: {
        id_salt: "",
        password: "",
        privkey: "",
        idkey: "",
        nickname: "",
      },
      users: {},
      channelusers: {},
      mychannelnames: [],
      focuschannel: "",
      chatlogs: [],
      newchannelname: "",
      input: "",
      signsend: function (payloadobj) {
        var encidkey = encode_base64(this.self_user.idkey);
        var payload = JSON.stringify(payloadobj);
        var signatureobj = sodium.crypto_sign_detached(payload, this.self_user.privkey);
        var signature = encode_base64(signatureobj);
        var obj = {idkey: encidkey, payload: payload, signature: signature};
        this.websocket.send(JSON.stringify(obj));
      },
      send_say: function (e) {
        e.preventDefault();
        this.input = this.input.trim();
        if (this.input === "") {return;}

        this.lastsay = moment();
        var sayobj = {} ; sayobj[this.focuschannel] = this.input;
        var payloadobj = {timestamp: moment().utc().format(),
                          nickname: this.self_user.nickname,
                          idle: false,
                          say: sayobj};

        this.signsend(payloadobj);

        // TODO don't erase input box unless/until message sent
        this.input = "";
      },
      send_listen: function () {
        var payloadobj = {timestamp: moment().utc().format(),
                          nickname: this.self_user.nickname,
                          idle: moment() - this.lastsay > this.idletimeout,
                          listen: this.mychannelnames};
        this.signsend(payloadobj);
      },
      send_who: function () {
        var payloadobj = {timestamp: moment().utc().format(),
                          who: "*"};
        this.signsend(payloadobj);
      },
      changechannel: function (ix) {
        if (document.getSelection().toString() != "") {return;}

        this.checkusers();
        app.focuschannel = app.mychannelnames[ix];
        inputfocus();
      },
      join: function (channel) {
        join_channel(channel);
      },
      leave: function (channel, e) {
        e.stopPropagation();
        leave_channel(channel);
      },
      shownewdiv: function() {
        this.newdiv_state = "show";
        Vue.nextTick(function () {
          app.$refs.newname.focus();
        });
      },
      hidenewdiv: function() {
        this.newchannelname = "";
        this.newdiv_state = "hide";
        inputfocus();
      },
      newchannel: function() {
        this.join(this.newchannelname);
        this.newchannelname = "";
        this.newdiv_state = "hide";
      },
      checkusers: function() {
        var now = moment();
        this.channelusers = {};

        // record my own channels
        var listening = this.self_user.mychannelnames;
        for (var ix in listening) {
          if (! (listening[ix] in this.channelusers)) {
            Vue.set(this.channelusers, listening[ix], {});
          }
          Vue.set(this.channelusers[listening[ix]], this.idkey_base64, true);
        }

        for (var youridkey in this.users) {
          var user = this.users[youridkey];
          if (youridkey != this.idkey_base64) {
            // checking someone else, not me
            if (now - user.lastseen > 120000) {
              // no word for 2 minutes, they're gone
              delete this.users[youridkey];
              continue;
            }
          }

          // if user is still around, record channel membership
          var listening = this.users[youridkey].listening;
          for (var ix in listening) {
            if (! (listening[ix] in this.channelusers)) {
              Vue.set(this.channelusers, listening[ix], {});
            }
            Vue.set(this.channelusers[listening[ix]], youridkey, true);
          }
        }

        this.$forceUpdate();
        update_icons();

        if (moment() - this.lastwho > 60000) {
          Vue.nextTick(function () {
            app.send_who();
          });
          this.lastwho = moment();
        }
      },
    },
    created: function () {
      this.timestampinterval = setInterval(() => this.$forceUpdate(), 60000);
      this.checkuserinterval = setInterval(() => this.checkusers(), 10000);
    },
    mounted: function () {
      this.$refs.id_salt.focus();
    },
    beforeDestroy() {
      clearInterval(this.timestampinterval);
      clearInterval(this.checkuserinterval);
    },
    computed: {
      sockstatecolor: function () {
        switch (this.sockstate) {
          case "notconnected":
            return "red";
            break;
          case "connecting":
            return "blue";
            break;
          case "connected":
            return "green";
            break;
          default:
            return "red";
            break;
        }
      },
      sockstatetext: function () {
        switch (this.sockstate) {
          case "notconnected":
            return "Not Connected";
            break;
          case "connecting":
            return "Connecting...";
            break;
          case "connected":
            return "Connected";
            break;
          default:
            return "ERROR";
            break;
        }
      },
      idkey_base64: function () {
        return encode_base64(this.self_user.idkey);
      },
      crack_time: function () {
        return zxcvbn(this.self_user.password).crack_times_display.offline_slow_hashing_1e4_per_second;
      },
      sorted_channel_users: function () {
        if (! (this.focuschannel in this.channelusers)) {return new Array();}

        var temp = Object.keys(this.channelusers[this.focuschannel]);
        temp.sort();
        return temp;
      },
      sorted_channels: function () {
        var temp = Object.keys(this.channelusers);
        temp.sort();
        return temp;
      },
    },
    filters: {
      fromNow(date) {
        return moment(date).fromNow();
      },
    },
  });
</script>

</body>
</html>
